
int hauteur =8; //Nombre de briques en hauteur
int largeur=6; //Nombre de briques en largeur
int tailleBrique = 20; //Taille en pixel du côté d'une brique
int xLanceur = 60; //Position en pixel du lanceur
int yLanceur = 160;



// on declare un tableaux de booleens pour representer les briques
String[][] briques = new String[hauteur][largeur];
int[] coordonees_clic = new int[2];
boolean clic = false;

void main() {
	//on crée l'image telles qu'une brique fasse 10*10 pixels
   reset(largeur*tailleBrique,hauteur*tailleBrique, false);   
	// Définition d'un runnable qui detcet les clics
	setRunnable(new Runnable() { public void run() {
		coordonees_clic[0]= getX(); 
         coordonees_clic[1] = getY();
	    clic = true;
	}});

   //Création et remplissage initial du tableau contenant les briques
    for (int i = 0; i < briques.length; i ++) {
      for (int j = 0; j < briques[0].length; j ++) {
         briques[i][j] = "vide";
      }
   }
   // on appelle la fonction finDeTour pour initialiser les briques
   finDeTour();
   
   //Entrée dans la boucle principale
    boolean continuer = true;
   while (continuer) {
      for (int i = 0; i < briques.length; i ++) {
         for (int j = 0; j < briques[0].length; j ++) {
            if (briques[i][j] != "vide") {
               dessinerBrique(j,i, briques[i][j]);
            } else {
               dessinerBrique(j,i, "white");
            }
         }
      }
      // on attend un clic de l'utilisateur
      while ( ! clic) {
         sleep(1);
      }
      lancer_balle(coordonees_clic[0], coordonees_clic[1]);
      clic = false;
      // si fin de tour retourne false c'est qu'on a perdu
      if ( ! finDeTour()) {
         continuer = false;
      }
   }
}

boolean finDeTour() {
   //On abaisse toutes les briques d'une ligne, et on genere la ligne du dessus
    //Si la ligne du bas n,'est pas vide avant dêtre abaissée, game over
    boolean perdu = false;
   for (int i = briques.length -1; i >= 0; i --) {
      for (int j = 0; j < briques[0].length; j ++) {
         if (i == briques.length -1 && briques[i][j] != "vide") {
            return  false;
         }
         if (i != 0) {
            //On copie les briques de la ligne au dessus si ce n'est pas la ligne tout au dessus
             briques[i][j] = briques[i -1][j];
         } else {
            //sinon , on genere une ligne.
             briques[i][j] = brique_au_hasard();
         }
      }
   }
   return  true;
}

void dessinerBrique(int x, int y, String color){
	for (int i = 0; i < tailleBrique; i++){
		for(int j = 0; j < tailleBrique; j++){
			setPixel(tailleBrique*x+i, tailleBrique*y+j, color);
		}
	}
}

void dessinerBalle(int x, int y, String couleur, int duree){
	int[] couleurOrigine = getPixelColor(x, y);
	setPixel(x, y, "black");
	sleep(duree);
	setPixel(x, y, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
}


void lancer_balle(int xArrivee, int yArrivee){
	//On calcule les coordonées du vecteur
	float a = ((float)-yArrivee+(float)yLanceur)/((float)xArrivee-(float)xLanceur);
	float b = -yLanceur-a*xLanceur;
	//si la balle part à gauche du lanceur
	if(xArrivee < xLanceur){
		for (int x = xLanceur; x >= 0; x--){
			int y = Math.round(a*x+b);
			//ne marche pas encore
			if (obstacle_present(x, -y) != "aucun" && !(x == xLanceur && -y==yLanceur)){
				//Si la balle rencontre une brique ou un rebord, on la fait rebondir
				//lancer_balle(jesaispas, jesaispas);
				println("Obstacle '" + obstacle_present(x, -y) + "'atteint en x=" + x + " et y =" +y);
				break;
			}
			dessinerBalle(x, -y, "black", 5);
			int[] couleurOrigine = getPixelColor(x, -y);
			setPixel(x, -y, "black");
			sleep(50);
			setPixel(x, -y, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
		}
	}
	else if (xArrivee == xLanceur){
		//jsp
	}
	else {
		for (int x = xLanceur; x <= largeur*tailleBrique; x++){
			int y = Math.round(a*x+b);
			//ne marche pas encore
			if (obstacle_present(x, -y) != "aucun"  && !(x == xLanceur && -y==yLanceur)){
				//Si la balle rencontre une brique ou un rebord, on la fait rebondir
				//lancer_balle(jesaispas, jesaispas);
				println("Obstacle '" + obstacle_present(x, -y) + "'atteint en x=" + x + " et y =" +y);
				break;
			}
			dessinerBalle(x, -y, "black", 10);
			int[] couleurOrigine = getPixelColor(x, -y);
			setPixel(x, -y, "black");
			sleep(50);
			setPixel(x, -y, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
		}
	}
}

String brique_au_hasard(){
	String couleur_briques[] = {"blue", "cyan", "black", "green", "magenta", "orange", "pink", "red", "yellow", "gray"};
	if (random() > 0.5){
		return "vide";
	}
	else {
   		int nombre_random = (int)floor(random()*10);
   		return couleur_briques[nombre_random];
	}
}

String obstacle_present(int x, int y){
	//on regarde si la balle a atteint une bordure
	if (y <= 0) return "bordure_haute";
	else if (y >= hauteur*tailleBrique) return "bordure_basse";
	else if (x <= 0) return "bordure_gauche";
	else if (x >= largeur*tailleBrique) return "bordure_droite";
	else {
		//La balle n'a atteint aucune bordure, on regarde maintenant si elle a atteint une brique
		//On cherche quelle ligne et colonne du tableau de briques correspond aux coordonées
		int xTab = x/tailleBrique;
		int yTab = y/tailleBrique;
		if (briques[yTab][xTab] == "vide") return "aucun";
		else {
			//La balle a atteint une brique, il faut maintenant savoir quel côté de la brique
			int yHaut = yTab*tailleBrique,
				yBas = yTab*tailleBrique+tailleBrique,
				xGauche=xTab*tailleBrique,
				xDroite=xTab*tailleBrique+tailleBrique;
			//Déjà on vérifie si c'est arrivé sur un coin
			if(x==xGauche&&y==yHaut) return "brique_coin_haut_gauche";
			else if (x==xDroite && y==yHaut) return "brique_coin_haut_droit";
			else if (x==xGauche && y==yBas) return "brique_coin_bas_gauche";
			else if (x==xDroite && y==yBas) return "brique_coin_bas_droit";
			//Sinon, on cherche le côté
			else {
				if (y==yHaut) return "brique_haut";
				else if (y==yBas) return "brique_bas";
				else if (x==xGauche) return "brique_gauche";
				else if (x==xDroite) return "brique_droit";
				//Au cas où
				else return "bizarre";
			}
			
		}
	}
}
