
int hauteur =8; //Nombre de briques en hauteur
int largeur=6; //Nombre de briques en largeur
int tailleBrique = 20; //Taille en pixel du côté d'une brique
int xLanceur = 60; //Position en pixel du lanceur
int yLanceur = 160;
int nb_tour;
int vert;
int bleu;
int rouge;

String couleur_briques[] = {"blue", "cyan", "black", "green", "magenta", "orange", "pink", "red", "white", "yellow"};
// on declare un tableaux de booleens pour representer les briques
int[][] briques = new int[hauteur][largeur];

int[] coordonees_clic = new int[2];
boolean clic = false;

void main() {
   vert =250;
   bleu =0;
   rouge =0;
   nb_tour =1;
	//on crée l'image telles qu'une brique fasse 10*10 pixels
   reset(largeur*tailleBrique,hauteur*tailleBrique, false);   
	// Définition d'un runnable qui detcet les clics
	setRunnable(new Runnable() { public void run() {
		coordonees_clic[0]= getX(); 
         coordonees_clic[1] = getY();
	    clic = true;
	}});

   //Création et remplissage initial du tableau contenant les briques
    for (int i = 0; i < briques.length; i ++) {
      for (int j = 0; j < briques[0].length; j ++) {
         briques[i][j] = false;
      }
   }
   // on appelle la fonction finDeTour pour initialiser les briques
   finDeTour();
   
   //Entrée dans la boucle principale
    boolean continuer = true;
  while (continuer) {
      for (int i = 0; i < briques.length; i ++) {
         for (int j = 0; j < briques[0].length; j ++) {
            if (briques[i][j] >0) {
               dessinerBrique(j, i, briques[i][j]);
            } else {
               dessinerBrique(j, i, 0);
            }
         }
      }
      // on attend un clic de l'utilisateur
      while ( ! clic) {
         sleep(1);
      }
      lancer_balle(coordonees_clic[0], coordonees_clic[1]);
      clic = false;
      // si fin de tour retourne false c'est qu'on a perdu
      if ( ! finDeTour()) {
         continuer = false;
      }
   }
}

boolean finDeTour() {
   //On abaisse toutes les briques d'une ligne, et on genere la ligne du dessus
    //Si la ligne du bas n,'est pas vide avant dêtre abaissée, game over
    boolean perdu = false;
   for (int i = briques.length -1; i >= 0; i --) {
      for (int j = 0; j < briques[0].length; j ++) {
         if (i == briques.length -1 && briques[i][j] >0) {
            return  false;
         }
         if (i != 0) {
            //On copie les briques de la ligne au dessus si ce n'est pas la ligne tout au dessus
             briques[i][j] = briques[i -1][j];
         } else {
            //sinon , on genere une ligne.
             boolean brique = random() >0.5;
            if (brique) {
               briques[i][j] = nb_tour;
            } else {
               briques[i][j] =0;
            }
         }
      }
      nb_tour ++;
   }
   return  true;
}

void dessinerBrique(int x, int y, int valeur_brique) {
	
	   	  vert = vert - valeur_brique*10;
            bleu = bleu + valeur_brique*10;
            rouge = rouge + valeur_brique*10;    
            
   for (int i = 0; i < 10; i ++) {       
      for (int j = 0; j < 10; j ++) {
         if (valeur_brique ==0) {         	
            setPixel(tailleBrique * x + i, tailleBrique * y + j, 255, 255, 255);
            
         } else {         	
            if (vert <0 || vert >250) {
               vert =220;
            }
            if (rouge <0 || rouge >250) {
               rouge =20;
            }
            if (bleu <0 || bleu >250) {
               bleu =20;
            }
            setPixel(tailleBrique * x + i, tailleBrique * y + j, rouge, vert, bleu);
         }
      }
   }
}

void dessinerBalle(int x, int y, String couleur, int duree){
	int[] couleurOrigine = getPixelColor(x, y);
	setPixel(x, y, "black");
	//setPixel(x-1, y, "black");
	//setPixel(x, y+1, "black");
	//setPixel(x+1, y, "black");
	//setPixel(x, y-1, "black");
	sleep(duree);
	setPixel(x, y, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
	//setPixel(x-1, y, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
	//setPixel(x, y+1, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
	//setPixel(x+1, y, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
	//setPixel(x, y-1, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
}


//Marche de temps en temps...
void lancer_balle(int xArrivee, int yArrivee){
	//On calcule les coordonées du vecteur
	float a = ((float)-yArrivee+(float)yLanceur)/((float)xArrivee-(float)xLanceur);
	float b = -yLanceur-a*xLanceur;
	//si la balle part à gauche du lanceur
	if(xArrivee < xLanceur){
		for (int x = xLanceur; x >= 0; x--){
			int y = Math.round(a*x+b);
			dessinerBalle(x, -y, "black", 5);
			int[] couleurOrigine = getPixelColor(x, -y);
			setPixel(x, -y, "black");
			sleep(50);
			setPixel(x, -y, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
		}
	}
	else if (xArrivee == xLanceur){
		//jsp
	}
	else {
		for (int x = xLanceur; x <= largeur*tailleBrique; x++){
			int y = Math.round(a*x+b);
			dessinerBalle(x, -y, "black", 10);
			int[] couleurOrigine = getPixelColor(x, -y);
			setPixel(x, -y, "black");
			sleep(50);
			setPixel(x, -y, couleurOrigine[0], couleurOrigine[1], couleurOrigine[2]);
		}
	}
}

String couleur_au_hasard(){
   int nombre_random = (int)floor(random()*10);
   return couleur_briques[nombre_random];
}